Wiznet-W5100-
=============

 
// =====  Простой веб-сервер на базе W5100 от  Wiznet  ======
//   * Для удобства использован Ардуиновский Ethernet Shield  
//   на базе W5100
//===========================================================


#include    <16F77.H>
 

#fuses HS                  // внешний кварц, высокочастотный

#use   delay(clock=16M) )  //   используется кварц на 16 МГц
                           //  если у Вас другой – укажите здесь

#use   rs232(baud=19200, xmit=PIN_A2, rcv=PIN_A3)
// определяем пины для RS232
// *  в CCS компайлере функция « printf» - встроенная, 
//  и можно использовать  вообще ЛЮБЫЕ пины ввода-вывода
 


// определяем пины PICa  для подключение к Ethernet  Shield

#define RESET   pin_B2       // *active LOW
#define MISO    pin_B3       //  input
#define MOSI    pin_B5       //  output
#define SS      pin_B0       // output.  SlaveSelect,  Active LOW
#define SCK     pin_B1       // output.  


#define SDA pin_C0
#define SCL pin_C1

 

//********** прописываем регистры   W5100  *********************
//**************************************************************

#define MR    0x0000  // MODE register

#define GAR0  0x0001  // GATEWAY Addr register0   (MSB)
#define GAR1  0x0002  // GATEWAY Addr register1
#define GAR2  0x0003  // GATEWAY Addr register2
#define GAR3  0x0004  // GATEWAY Addr register3   (LSB)

#define SUBR0 0x0005  // SUBNET MASK Addr register0  (MSB)
#define SUBR1 0x0006  // SUBNET MASK Addr register1
#define SUBR2 0x0007  // SUBNET MASK Addr register2
#define SUBR3 0x0008  // SUBNET MASK Addr register3   (LSB)

// MAC адрес сервера
#define SHAR0 0x0009  // SOURCE HARDWARE  Addr register0 (MSB)
#define SHAR1 0x000A  // SOURCE HARDWARE  Addr register1
#define SHAR2 0x000B  // SOURCE HARDWARE  Addr register2
#define SHAR3 0x000C  // SOURCE HARDWARE  Addr register3
#define SHAR4 0x000D  // SOURCE HARDWARE  Addr register4
#define SHAR5 0x000E  // SOURCE HARDWARE  Addr register5  (LSB)

#define SIPR0 0x000F  // Source IP  Addr register0  (MSB)
#define SIPR1 0x0010  // Source IP  Addr register1
#define SIPR2 0x0011  // Source IP  Addr register2
#define SIPR3 0x0012  // Source IP  Addr register3  (LSB)



#define RMSR  0x001A  // RX memory size  (1K,2K,4K or 8K per socket, from total 8K)
#define TMSR  0x001B  // TX memory size  (1K,2K,4K or 8K per socket, from total 8K)



//-- Регистры  Socket0 (* в примере используется только этот Сокет )

#define S0_MR   0x0400   // Socket0 MODE register
#define S0_CR   0x0401   // Socket0 COMMAND register

 
#define S0_SR   0x0403   // Socket0 STATUS register

#define S0_PORT0   0x0404   // Socket0 SOURCE Port register0 (H byte)
#define S0_PORT1   0x0405   // Socket0 SOURCE Port register1 (L byte)

 

#define S0_TX_FSR0    0x0420   // Socket0 TX Free SIZE register0
#define S0_TX_FSR1    0x0421   // Socket0 TX Free SIZE register1

#define S0_TX_RD0    0x0422   // Socket0 TX Read POINTER register0
#define S0_TX_RD1    0x0423   // Socket0 TX Read POINTER register1

#define S0_TX_WR0    0x0424   // Socket0 TX Write POINTER register0
#define S0_TX_WR1    0x0425   // Socket0 TX Write POINTER register1


#define S0_RX_RSR0  0x0426   // Socket0 RX Received SIZE register0 (H byte)
#define S0_RX_RSR1  0x0427   // Socket0 RX Received SIZE register1 ( L byte)

#define S0_RX_RD0  0x0428   // Socket0 RX Read POINTER0  (H byte)
#define S0_RX_RD1  0x0429   // Socket0 RX Read POINTER1  (L byte)



// ----- Коды команд ( используются в  Регистре Команд Сокета0 ) -----
#define OPEN     0x01
#define LISTEN   0x02
#define CONNECT  0x04
#define DISCON   0x08
#define CLOSE    0x10
#define SEND     0x20
#define SEND_MAC   0x21
#define SEND_KEEP   0x02
#define RECV     0x40


// ----- Коды состояний ( используются в Регистре STATUS  сокета0 ) ---
#define SOCK_CLOSED     0x00
#define SOCK_INIT       0x13
#define SOCK_LISTEN     0x14
#define SOCK_ESTABLISHED   0x17
#define SOCK_CLOSE_WAIT    0x1C
 

// ---------- определяем «свои» переменные  -----------
#define SERVER_IP0   192   //  Наш сервер будет  192.168.0.155
#define SERVER_IP1   168
#define SERVER_IP2    0    
#define SERVER_IP3   155    

#define SERVER_PORT0   0   //  Наш порт будет       :80
#define SERVER_PORT1   80
 
#define GATEWAY_IP0   192  // Гэйтвэй адрес. Если у Вас другой - измените
#define GATEWAY_IP1   168
#define GATEWAY_IP2   0
#define GATEWAY_IP3   254

#define SUBNET_MASK0   255  // Маска подсети  ( Типовая)
#define SUBNET_MASK1   255
#define SUBNET_MASK2   255
#define SUBNET_MASK3   0

#define MAC0   0x00  // МАС адрес любой, главное, чтобы в Вашей сети
#define MAC1   0x1A  // не было устройств  с таким же  МАС
#define MAC2   0x2B
#define MAC3   0x3C
#define MAC4   0x4D
#define MAC5   0x5E

 
 
 
//----------- объявляем собственные функции  ---------------

void SSPI_write(int Data);      // запись  1 байта в W5100   через SPI
int  SSPI_read ( void);         // чтение 1 байта из W5100 через SPI 

void SetW5100register (int16 regaddr, int data);  
                // установка(запись) грегистров W5100  через SPI

int  GetW5100register (int16 regaddr);               
                // чтение байта из регистров W5100 через SPI


void Init (void);          // инициализация W5100  и Системы

int Open_Socket0(void);    // открывает сокет и возвращает статус (удачно/неудачно)

int Listen_Socket0(void);   // слушает сокет и возвращает статус (удачно/неудачно)

int Socket0_Connection_Established (void);   
     // проверка или соединение установлено и возвращает статус  (да/нет)

int Socket0_Received_Data_Size (void);       
      //  возвращает размер блока ДАННЫХ, принятых от Клиента ( 0 если данных нет) 

            void Socket0_Received_Data_Reading (void);
           // выводит на терминал принятые данные
           // после отладки ф-ция может быть удалена
 
int  Socket0_FIN_Received(void);      
  // проверяет  пришел ли от Клиента флаг FIN  и возвращает да/нет

void Socket0_Disconnect(void);  
  // пишет в регистр W5100  команду на разрыв соединения

int  Socket0_Closed(void);    // поверяет или Сокет ЗАКРЫТ и возвращает да/нет          

int  Socket0_Connection_Timeout(void);  
   // проверяет не произошел ли тайм-аут соединения  и возвращает да/нет

void Socket0_Closing(void);           // закрывает Сокет

int  Socket0_Received_Request_is_index_html(void);  
  // проверяет или  в данных принятых от Клиента запрашивается файл Index.html
  //  и возвращает да/нет


void Socket0_Send_index_html (void);  // отсылает Клиенту  «страничку»  index.html

  
void Socket0_Send_404_error (void); // Отсылает Клиенту  «страничку»  «ошибка 404»


//------------  собственные переменные  -----------------------------------

int16 S0_RX_BASE;      //  начальный адрес памяти, выделенной в RX буфере для Сокета0
int16 S0_RX_MASK;      // РАЗМЕР RX  буфера Сокета0
int16 S0_RX_OFFSET;    // указатель на начало принятого блока данных в RX буфере 
int16 S0_RX_Start_Addr; // ФИЗИЧЕСКИЙ  адрес начала принтого блока данных в RX буфере 
int16 S0_RX_RSR ;       //  РАЗМЕР принятого от Клиента блока данных

int16 S0_TX_BASE;    // начальный адрес памяти, выделенной в ТX буфере для Сокета0
int16 S0_TX_MASK;     // РАЗМЕР ТX  буфера Сокета0
int16 S0_TX_OFFSET ;  
   // указатель на начальный  адрес в памяти  ТХ буфера, куда следует записать блок 
   // данных для передачи Клиенту  

int16 S0_TX_Start_Addr;  
       // ФИЗИЧЕСКИЙ  Начальный адрес в памяти ТХ буфера, куда следует записать 
       // блок  данных для передачи Клиенту  

int16 S0_TX_End_Addr; 
   // указатель на Конечный адрес в памяти ТХ буфера, до которого W5100
   //  должен дойти при считывании данных отсылаемых Клиенту


// --- строки символов для использования как HTTP  заголовки и «веб-странички»
// * размер  массива [222] взят с потолка и с запасом. Потом программа его расчитает 
// ** CONST – чтобы  расположить строку в ПРОГРАММНОЙ памяти ( где места полно)

CONST  char INDEX[222]  = { "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 43\r\n\r\n<HTML><CENTER>HELLO WORLD !</CENTER></HTML>"};
// символы для  создания  странички «index.html”

CONST  char ERROR404[222] = { "HTTP/1.1 200 OK\r\nContent-Type: text/html\r\nContent-Lenght: 39\r\n\r\n<HTML><CENTER>ERROR 404</CENTER></HTML>"};
// символы для  создания  странички «ошибка 404”

 
// закомментил чтоб была на примете,
//  Можно  использовать и такой вариант для «ошибка 404», код сам по себе верный, но...
//CONST  char ERROR404[222] = { "HTTP/1.1 404 Page not found\r\nContent-Type: text/html\r\nContent-Lenght: 39\r\n\r\n<HTML><CENTER>ERROR 404</CENTER></HTML>"};
// .. но IExplorer  получив в HTTP заголовке "HTTP/1.1 404 Page not found" 
// отобразит СОБСТВЕННУЮ страницу ошибки, а НЕ ту, что мы ему посылаем






         int try=0;  //  временно, для отладки. Номер обращения браузера –к серверу


//===================== MAIN ============================================
//=======================================================================
void main()
{

   
Init();   // инициализация  W5100  и системы ( сервера)

 

OpenSocket0:     

//ooooooooooooooooooo ОТКРЫВАЕМ СОКЕТ 0 oooooooooooooooooooooooo

 if ( ! Open_Socket0() ) goto OpenSocket0; // цикл пока Сокет не откроется


 
//ooooooooooooooooo  СЛУШАЕМ СОКЕТ  ooooooooooooooooooooooooo

 if ( Listen_Socket0() == FALSE ) goto OpenSocket0;

            // если  сокет не «прослушивается» - уходим заново на открытие сокета

 
//oooooooooooooo Соединение УСТАНОВЛЕНО ? oooooooooooooo

CheckConnection:     //метка

  if (Socket0_Connection_Established() == FALSE ) goto CheckConnection;
// цикл пока соединение не установится ( тоесть пока не придет запрос от браузера)
    
                   printf("> Connection Established... \r\n");
                   // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
                   
                   
                   
//ooooooo( соединение уже установлено)  в принятых пакетах -  ДАННЫЕ? oooooo               
                   
  if  ( Socket0_Received_Data_Size() == 0 )  
  
  {
      printf("\r\n> (Zero) Received Data size is: %Lu (bytes) \r\n", S0_RX_RSR);
                   // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
  
  goto CheckFIN;   // nehuj idti na Send Data esli prishel ZERO PACKET !
  }
  // раз данных нет ( размер=0) то уходим на этап проверки закрытия соединения



  
   else    
   {
   printf("\r\n> (NonZero) Received Data size is: %Lu (bytes) \r\n", S0_RX_RSR);
                   // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
   }
  
 
// oooooooooo ( Данные в пакете есть) Процесс обработки*   ooooooooooooooo 

//на самом деле просто  выводит на терминал принятые данные
// после отладки этот кусок можно удалить


                 Socket0_Received_Data_Reading();   
                   // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
        


    
// oooooooooooooo  Процесс ПЕРЕДАЧИ данных  ooooooooooooooooooooooooooooooo
// тоесть отсылаем браузеру HTTP заголовок и HTML страничку

 
if ( Socket0_Received_Request_is_index_html() ==  TRUE)   Socket0_Send_index_html ();
   // если  клиент запрашивает "index.html"  то остылаем ему  index.html

else  Socket0_Send_404_error (); 
   //  если запрос любого другого файла  то  отсылаем  «страничку»  «ошибка 404»
   
  


//ooooooooooo    Получен флаг  FIN ? ooooooooooooooooooooooooooo

//  тоесть проверка требует ли  Клиент разрыва соединения

CheckFIN:

if ( Socket0_FIN_Received() == TRUE) goto  CloseConnection;

     //  если FIN  пришел  - то  уходим закрывать СОКЕТ0





//ooooooooooo    Разрыв соединения   ooooooooooooooooooooooo 


  Socket0_Disconnect();    //  разрыв СОЕДИНЕНИЯ Сокета0





//ooooooooooo   Сокет ЗАКРЫТ ?    ooooooooooooooooooooooooooooooo

if (Socket0_Closed() == TRUE )  goto CloseConnection;
    // если Сокет закрыт – уходим закрывать Соединение




//ooooooooooo   Не наступил ли тайм-аут по соединению  ?  ooooooooooooooooooo


if ( Socket0_Connection_Timeout() == TRUE)  goto CloseConnection;
  // сокет не закрыт, но наступил тайм-аут, – уходим закрывать сокет




CloseConnection:

//ooooooooooo   Закрываем Сокет    ooooooooooooooooooooooooooooooooooo
 
  Socket0_Closing(); 
 

 
 
 
//oooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooo






goto OpenSocket0;   

// соединение с Клиентом отработано, цикл завершился.
//  Уходим в начало и запускаем все по новой ( ждем новых запросов «веб-сайта» )
 
}


//===================  END of MAIN ===========================
//============================================================





//---------------------------------------------------------------
//--------------------------INIT -------------------------------
void Init (void)
{


output_low(RESET); //  генерируем «Сброс» для Ардуиновского Ethernet  шилда 
delay_ms(1);
output_high(RESET);

output_low(SCK);     // готовим пины (уровни) для  SPI
output_high(SS) ;

//программный сброс чипа W5100.
SetW5100register(MR, 0x80);   // пишем код  RST  в W5100 Mode Register



//------------ Настраиваем  память (W5100) для Сокета 0 -------------
 
 

SetW5100register(RMSR, 0x55);   // настраиваем RX буфер: по 2КБ под каждый сокет 


S0_RX_BASE = 0x6000;     //  базовый адрес RX  буфера    для Сокета0

S0_RX_MASK = 0x07FF ;   // (2048 -1 )= 0x07FF, RX Маска ( = длина_буфера – 1 )


SetW5100register(TMSR, 0x55);   // настраиваем ТX буфер: по 2КБ под каждый сокет
 
S0_TX_BASE = 0x4000;  // базовый адрес TX буфера  для Сокета0
 
S0_TX_MASK = 0x07FF;  // (2048 -1 )= 0x07FF, ТХ Маска ( = длина_буфера – 1 )

 

//------------ прописываем свой МАС адрес   --------------
//  т.е.  просто закидываем в МАС регистры W5100 
//    – свои переменные  с определенными ранее величинами


 SetW5100register(SHAR0, MAC0);  
 SetW5100register(SHAR1, MAC1); 
 SetW5100register(SHAR2, MAC2);
 SetW5100register(SHAR3, MAC3);
 SetW5100register(SHAR4, MAC4);
 SetW5100register(SHAR5, MAC5);
  
 
//------------  прописываем свой  IP  --------------
// так же -  раскидываем в регистры W5100 – свои переменные

SetW5100register(SIPR0, SERVER_IP0);
SetW5100register(SIPR1, SERVER_IP1);
SetW5100register(SIPR2, SERVER_IP2);
SetW5100register(SIPR3, SERVER_IP3);

 

//------------  прописываем свой PORT  --------------
// так же – свои константы – в регистры

SetW5100register(S0_PORT0, SERVER_PORT0);
SetW5100register(S0_PORT1, SERVER_PORT1); 

//------------ прописываем  Gateway addr  --------------
// так же – свои константы – в регистры

SetW5100register(GAR0, GATEWAY_IP0); 
SetW5100register(GAR1, GATEWAY_IP1); 
SetW5100register(GAR2, GATEWAY_IP2); 
SetW5100register(GAR3, GATEWAY_IP3); 

//------------ set Subnet Mask  --------------

SetW5100register(SUBR0, SUBNET_MASK0); 
SetW5100register(SUBR1, SUBNET_MASK1); 
SetW5100register(SUBR2, SUBNET_MASK2); 
SetW5100register(SUBR3, SUBNET_MASK3); 
 
      printf(" \r\n\r\n > =============== W5100 ВЕБ-СЕРВЕР ==========\r\n\r\n");
      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
}





//--------------------------------------------------------------
//-------------  ОТКРЫТИЕ СОКЕТА 0  ----------------------------

int Open_Socket0(void)
{

                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

                 printf(" \r\n =========== TRY # %u   ====================\r\n", try);
                 if (try ==255) try =0;
                 else try++;
              
              
                 printf("\r\n>  Start Open Socket... \r\n");
          
              


// устанавливаем Сокет – в режим ТСР, остальные опции отключаем 
SetW5100register(S0_MR, 0x01);   

// засылаем в регистр команд – команду ОТКРЫТЬ ( сокет)
SetW5100register(S0_CR, OPEN);  

// проверяем или сокет открылся успешно
// * в режиме ТСР , по  «SOCK_INIT»  можно проверить или сокет открылся
if (GetW5100register(S0_SR) != SOCK_INIT)  // проверяем STATUS регистр
   {
    SetW5100register(S0_CR, CLOSE); // если не открылся то закрываем
    return FALSE ;                //  и выходим с кодом 0
   }

 return TRUE;     //открылся успешно.  Выходим с кодом 1
}




//--------------------------------------------------------------
//-------------  Переводим Сокет0 в режим  СЛУШАТЬ  ------------

int Listen_Socket0 (void)
{
 
                 printf("> Sock opened. Go Listen... \r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


// засылаем в регистр команд команду перевода сокета в режим СЛУШАТЬ
// *СЛУШАТЬ – т.к. мы – Сервер, а инициатива  исходит от Клиента

SetW5100register(S0_CR, LISTEN);  


if ( GetW5100register(S0_SR) != SOCK_LISTEN)  //  проверяем  Регистр Состояния
 {
  SetW5100register(S0_CR, CLOSE); //  если сокет не вошел в режим СЛУШАТь
  return FALSE;                   // закрываем его и выходим с кодом 0   
 } 
 
return TRUE;               //  сокет в режиме СЛУШАТЬ,  выходим с  кодом 1
 
}


//--------------------------------------------------------------------------
//-------------   проверка Установлено  ли  соединение с  Сокетом0 ? --------
// * в смысле от клиента ( браузера)

int Socket0_Connection_Established(void)
{

// если W5100  получает от клиента запрос на соединение, он отсылает ему пакет 
// с  установленным флагом ACK и  изменяет свой статуст на SOCK_ESTABLISHED
// («соединение с сокетом установлено)
// Проверить это можно либо  проверкой бита в регистре прерываний, 
// либо как здесь -  проверкой  регистра состояния


if  ( GetW5100register(S0_SR) == SOCK_ESTABLISHED)  return TRUE ;

// читаем Регистр Состояния.  
// Если  комбинация битов (код) = «SOCK_ESTABLISHED» то выходим с 1

else return FALSE;     // если нет – выходим с кодом 0


                // printf("> Connection Established... \r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


// *после того как соединение установлено,  сокет готов к приему/передаче данных

}



//----    проверка были ли приняты ДАННЫЕ -------------
//-----------------------------------------------------

// * «служебные» пакеты между сторонами  соединения могут и пересылаться
// но нас интересует были ли в них именно ДАННЫЕ
//  (например, запрос  страницы/файла  с веб-сервера)


int Socket0_Received_Data_Size (void)  

// на самом деле  интересует   размер принятых данных = НОЛЬ или нет

{

S0_RX_RSR = make16 (GetW5100register(S0_RX_RSR0), GetW5100register(S0_RX_RSR1) );  
// читаем два  8-битных регистра размера принятых данных 
// RSR0 – старш байт, RSR1 – младш байт
// и «собираем» 16-битное слово -  размер принятых данных


                printf("> Received Data size is: %Lu (bytes) \r\n", S0_RX_RSR);
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

if (S0_RX_RSR == 0 ) return FALSE;   // нет ДАННЫХ ( т.е. размер=0 )
                                     // выходим с кодом 0

else  return TRUE;    // размер данных не нулевой ( т.е. данные  -есть)
                      // выходим с кодом 1



}

//---------- вывод на терминал принятых ДАННЫХ ---------------
//------------------------------------------------------------
// * функция  полезна только при отладке.  Ее МОЖНО УДАЛИТЬ

void Socket0_Received_Data_Reading (void) 
{
 int16 n; 
 int RXbyte;


  S0_RX_OFFSET = make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) );  
// из двух  8-разрядных регистров  склеиваем  16 разрядную переменную -
// УКАЗАТЕЛЬ на  начало  принятых данных в RX буфере  сокета0


                 printf("> S0_RX_RD (RX mem read pointer) = %LX \r\n", make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) )  );
       

  S0_RX_OFFSET = (S0_RX_OFFSET & S0_RX_MASK ) ;
 // отсекаем лишнее  чтобы  укладывался в размеры выделенного под Сокет0 буфера

                 printf("> S0_RX_Offset = S0_RX_RD & S0_RX_MASK = %LX \r\n\r\n",S0_RX_OFFSET );
    

  S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE ;

//вычисляем ФИЗИЧЕСКИЙ адрес начала  области памяти хранящей принятые данные


                 printf("> S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE = %LX (physical)\r\n\r\n", S0_RX_Start_Addr );
 

                  printf(">  Going  to print-out Received Data... \r\n\r\n");
                  printf("ooooooooooooooooooooooooooooooooooooooooooo\r\n");


for (n=0; n < S0_RX_RSR ; n++)   
 {
  
   if ( S0_RX_Start_Addr > (S0_RX_BASE + S0_RX_MASK)  )  S0_RX_Start_Addr = S0_RX_BASE;

   RXbyte = GetW5100register(S0_RX_Start_Addr);
  
  
                   printf("%c", RXbyte);

   S0_RX_Start_Addr++;
 
 }

                   printf("\r\noooooooooooooooo END of  received data oooooooooooooo\r\n\r\n");
                   
 
}


// --- проверяем или от Клиента пришел запрос на INDEX.HTML  файл ------
//----------------------------------------------------------------------

int Socket0_Received_Request_is_index_html(void)  
{
int RXbyte=0;

 S0_RX_OFFSET = make16 ( GetW5100register(S0_RX_RD0), GetW5100register(S0_RX_RD1) );  
// из двух  8-разрядных регистров  склеиваем  16 разрядную переменную -
// УКАЗАТЕЛЬ на  начало  принятых данных в RX буфере  сокета0


 

 S0_RX_OFFSET = (S0_RX_OFFSET & S0_RX_MASK ) ;
// отсекаем лишнее  чтобы  укладывался в размеры выделенного под Сокет0 буфера

 
 S0_RX_Start_Addr = S0_RX_OFFSET + S0_RX_BASE ;  
//вычисляем ФИЗИЧЕСКИЙ адрес начала  области памяти хранящей принятые данные

  
 
 
                printf("\r\n>----------- parsing HTTP header-------------\r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

 
 while (RXbyte != 0x2F)   // ищем первый  "/"  в HTTP  заголовке
 {
  
    if ( S0_RX_Start_Addr > (S0_RX_BASE + S0_RX_MASK)  )  S0_RX_Start_Addr = S0_RX_BASE;
// начало блока данных не обязательно м располагаться в начале  буфера
// проверяем, не дошли  ли до КОНЦА  буфера
// если да – идем в самое НАЧАЛО буфера – данный продолжаются именно с того места

   RXbyte = GetW5100register(S0_RX_Start_Addr);  
// читаем из буфера RX байт,  на который  указывает СтартовыйАДрес
  
  
                      printf("%c", RXbyte);
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


   S0_RX_Start_Addr++;  // инкрементируем Адрес – теперь он указывает на следующ юайт
 
 }
 
// раз мы здесь значит уже дошли («отловили») до первого в HTTP заголовке символа “/”
// и сейчас Адрес  указывает на следующий за "/"  символ.  
// Ради него и затевался весь сыр-бор

    RXbyte = GetW5100register(S0_RX_Start_Addr); //считываем этот  символ
 
 
 
          printf("\r\n> -------- END of parsing HTTP header -------\r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ


 
     if (RXbyte == 0x20)  return TRUE;  
// если это «пробел»  - значит клиент запрашивает файл без названия, тоесть index.html
//  выходим с кодом подтверждения 1

     else return FALSE;                
// если это был не пробел а любой другой символ, значит  запрашивается НЕ index.html
// выходим с кодом ошибки - 0

}





//------   отправка Клиенту страницы «ошибка 404» ------------
//-------------------------------------------------------------

// заполняем ТХ буфер сокета0  блоком данных из HTTP заголовка и   HTML  кода
//  страницы «ошибка 404»,  затем  показываем W5100  начало и конец 
// этого блока данных в буфере,  и даем команду  ОТОСЛАТЬ

void Socket0_Send_404_error (void) 
{   int16 n;
char TXbyte;
int16 datalength;



  S0_TX_OFFSET = make16 ( GetW5100register(S0_TX_RD0), GetW5100register(S0_TX_RD1) );  // из двух  8-разрядных регистров  склеиваем  16 разрядную переменную - УКАЗАТЕЛЬ 
// на  место, откуда можно начать размещать блок данных в ТX буфере  сокета0
  
  
  S0_TX_OFFSET = (S0_TX_OFFSET & S0_TX_MASK ) ;
// отсекаем лишнее  чтобы  укладывался в размеры выделенного под Сокет0 буфера
  
  
  S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE ;
//вычисляем ФИЗИЧЕСКИЙ начальный адрес для размещения блока данных в буфере ТХ
  

  //вычисляем ДЛИНУ строки  содержащей HTTP заголовки и HTML  коды
  datalength=0;
  while ( ERROR404[datalength] !=0) datalength++;  
// попросту  инкрементируем «datalength» пока не наткнемся на первый 0х00 в строке
//  (0х00 -  признак конца данных)
 
 


// Для того, чтобы W5100 передала блок Данных, его необходимо разместить 
// в ТХ буфере Сокета, начиная с адреса, который ммы вычислили ранее.
// После этого, W5100 необходимо указать   КОНЕЦ блока данных в буфере.

// Указание на конец нашего блока данных мы записываем в соотв регистр W5100:


// Вытаскиваем из пары регистров - указателей конца блока данных их текущее значение
// и склеиваем из них  2-байтный указатель
// *( в отличие от предыдущего  вычисления ФИЗИЧЕСКОГО адреса начала длока данных
// здесь мы имеем дело именно с «внутренним» указателем адреса)
  S0_TX_End_Addr = make16 ( GetW5100register(S0_TX_WR0), GetW5100register(S0_TX_WR1) );  

// добавляем к получившемуся -  вычисленную ранее длину нашего блока данных
      S0_TX_End_Addr += datalength ;      // increment to  fatalength
   // получившееся  значение ( указатель на конец наших данных) вновь «расклеииваем» 
   // на  2 байта и  записываем в  соотв  регистры   
      SetW5100register(S0_TX_WR0, make8( S0_TX_End_Addr ,1) );  // старший байт 
      SetW5100register(S0_TX_WR1, make8( S0_TX_End_Addr,0) );  // младший байт
 
      
                 printf("\r\n>Data length is: %Lu \r\n", datalength);
                 printf("\r\n>--- Filling TX buffer  w  data: -----------\r\n");
                 // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
      
      
 // теперь приступаем к собственно заполнению  буфера ТХ – нашими  данными
For (n=0; n < datalength; n++)  // цикл  на длину блока данных
  {
     TXbyte = ERROR404[n];  
// читаем текущий байт из строки,  в которой записан весь код «веб страницы»
// ( HTTP заголовки и  HTML коды)
 

// поскольку «выданный» нам от W5100  адрес начала блока данных в ТХ буфере  
// может не совпадать с  началом  буфера, а  находиться, например в 10 байтах
// от конца буфера, необходимо при записи каждого нового байта наших данных
// проверять, не вылезли  ли  мы за границы буфера
 
  if (S0_TX_Start_Addr  > (S0_TX_BASE + S0_TX_MASK)) S0_TX_Start_Addr = S0_TX_BASE;
 // .. и если  дошли до края буфера – то   продолжать следует с НАЧАЛА буфера

// * W5100  в курсе этих манипуляций (это  вообще была  ее  идея а не наша ))и когда //будет передавать данные  - также, в  случае, когда дойдет до конца буфера  
//( именно БУФЕРА,  а НЕ до указателя на КОНЕЦ Данных) – также будет продолжать
//  от начала буфера
 

 // с ТЕКУЩИМ адресом  записи текущего байта мы разобрались выше 
// и сейчас просто пишем текущий байт данных – в  соотв  ячейку памяти буфера ТХ 
  SetW5100register( S0_TX_Start_Addr, TXbyte ) ;   
  
               
                       putc(TXbyte);   
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

  S0_TX_Start_Addr++ ;
  // инкрементируем текущий адрес (для записи следующего байта данных)
  
  }     
      
                  printf("\r\n>--- end of  Filling  -----------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

// все, все данные для передачи мы разместили в буфере, 
// указали, где наши данные заканчиваются, теперь можно их и передавать    
  
    //  засылаем в Регистр Команд сокета  - команду SEND  
    SetW5100register(S0_CR, SEND);       
      
                    printf("> Data was  sent \r\n\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

}


//-----------------------------------------------------------

//-- отправка Клиенту страницы «index.html» ---------------
//-------------------------------------------------------------------
void Socket0_Send_index_html (void) // send index.html "page"  index.html
{

// расписывать не стану – все абсолютно так же как при посылке страницы «ошибка 404»
// только  «строка»  содержащая  HTTP  заголовки и  HTML  коды – другая

int16 n;
char TXbyte;
int16 datalength;

                    printf("\r\n>......  going to send INDEX.HTML.....\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

  S0_TX_OFFSET = make16 ( GetW5100register(S0_TX_RD0), GetW5100register(S0_TX_RD1) );  // склеиваем  2-байтный указатель на началь адрес для размещения блока данных
  
  
  S0_TX_OFFSET = (S0_TX_OFFSET & S0_TX_MASK ) ;
  
  
  S0_TX_Start_Addr = S0_TX_OFFSET + S0_TX_BASE ;
  // вычисляем ФИЗИЧЕСКИЙ  начальный адрес  для размещения блока данных


                   printf("\r\n  INDEX[i], datalegth -------------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
      
      
  //вычисляем ДЛИНУ блока данных
  datalength=0;

  while ( INDEX[datalength] !=0) datalength++; 
 // считаем длину данных – пока не дойдем до первого  0х00 – признака конца данных
  
                    printf("%c  %Lu ",INDEX[datalength], datalength );
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
               
      
       

// записываем в  W5100  УКАЗАТЕЛЬ  на КОНЕЦ блока данных на передачу
 S0_TX_End_Addr = make16 ( GetW5100register(S0_TX_WR0), GetW5100register(S0_TX_WR1) );  // «склеиваем» вместе 2 байта текущего  значения

      S0_TX_End_Addr += datalength ;      // increment to  fatalength
      // добавляем длину нашего блока данных

 // новое значение заново распихиваем по двум 1-байтным регистрам     
      SetW5100register(S0_TX_WR0, make8( S0_TX_End_Addr ,1) );  // старш байт
      SetW5100register(S0_TX_WR1, make8( S0_TX_End_Addr,0) );  // младш байт

                 
                  printf("\r\n>Data length is: %Lu \r\n", datalength);
                  printf("\r\n>--- Filling TX buffer  w  data: -----------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
           
      
 // заполняем буфер – нашими данными на передачу
For (n=0; n < datalength; n++)
  {
   TXbyte= INDEX[n]; 
// читаем текущий байт из строки  содержащей «веб страницу»  index.html
// (т.е.   HTTP Header  + HTML code)
  
  if (S0_TX_Start_Addr  > (S0_TX_BASE + S0_TX_MASK)) S0_TX_Start_Addr = S0_TX_BASE;
  // проверяем не дошли ли до края буфера, и если да – перескакиваем на начало
  
  SetW5100register( S0_TX_Start_Addr, TXbyte ) ;  
   // зарисываем текущий байт блока данных ( «веб страницы») – в  буфер ТХ 
  

                putc(TXbyte);  // printout to Terminal ( for testing purpose)
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
   
  S0_TX_Start_Addr++ ;
  // переходим к следующему адресу ТХ буфера
  
  }     
      
                 printf("\r\n>--- end of  Filling  -----------\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
    
  // буфер заполнен нашим блоком данных, можно их передавать Клиенту

    //  пишем в Регистр Команд сокета - команду SEND  
    SetW5100register(S0_CR, SEND);       
      
                     printf("> Data was  sent \r\n\r\n");
                    // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

}

//--------------------------------------------------------

 

//--- содержит ли пакет, пришедший от Клиента,  установленный флаг FIN ? ------
//-----------------------------------------------------------------------------

int Socket0_FIN_Received(void)
{ 
// проверяем  не пожелал ли  клиент разрыва отношений (тоесть соединения)
// послав нам  флаг FIN  -  запрос на разрыв соединения

// можно проверять через проверку бита в регистре прерываний
// либо как здесь – через проверку  Регистра Состояния Сокета0


// выходим с  1  если  FIN пришел  и  с 0  если  FINа не было
if ( GetW5100register(S0_SR) == SOCK_CLOSE_WAIT) return TRUE;
else return FALSE;

}


//---------------------------------------------------------


 
// ------ разрываем СОЕДИНЕНИЕ для  Socket0   -----------------
//-------------------------------------------------------------
void Socket0_Disconnect(void)
{


//  отключаем сокет от СОЕДИНЕНИЯ с клиентом
// заслав соотв команду в Регистр Команд  сокета0

SetW5100register(S0_CR, DISCON);

}





// ------  проверка или Сокет0 ЗАКРЫТ --------------------
//--------------------------------------------------------
int Socket0_Closed(void)
{
// Сокет мож быть закрыт после засылки нами в Регистр Команд Сокета
//  команды ЗАКРЫТь (CLOSE), или  после тайм-аута, или  при разрыве соединения

// проверка или  Сокет0 действительно закрыт

// * можно делать через проверку  бита в регистре прерываний,
// либо как здесь -  проверкой Регистра Состояния
 

If  ( GetW5100register(S0_SR) == SOCK_CLOSED) return TRUE;
else return FALSE;
// выходим с 1  если Сокет (или СОЕДИНЕНИЕ сокета0) закрыто
// либо с 0 если сокет  до сих пор не закрылся


}





 
// -----  нет ли ТАЙМ-АУТа по соединению Сокета0 ? ------------
//-------------------------------------------------------------

int Socket0_Connection_Timeout(void)
{
// если на линии ошибки, или  клиент хочет закрыть соединение, или  от клиента давно
// ничего не приходит   итп – проверяем соединение на тайм-аут
//  иначе будет некорректно,  если наш  сервер будет слать клиенту пакеты
// ( с  соответствующими TCP флагами ) в том порядке, который подразумевается 
// для нормального процесса обмена пакетами


// тайм-аут проверяется либо через биты в  регистре прерываний
// либо как у нас – через проверку Регистра Состояния сокета0

// ПРИЕЧАНИЕ: как видим, регистр проверяется на состояние «SOCK_CLOSED»
// - какая тут связь с тайм-аутом??
// Дело в том что в Регистре Состояний нет отдельного кода для тайм-аут,
// но в W5100  код «SOCK_CLOSED»  связан также и  с тайм-аутом
// поэтому  проверка на этот код – вполне легитимна

If  ( GetW5100register(S0_SR) == SOCK_CLOSED) return TRUE;
else return FALSE;

// выходим с 1  если   тайм-аут  наступил, либо с 0 если тайм-аута не было

}



// ------------  ЗАКРЫТИЕ Сокета0    ----------------------------
//----------------------------------------------------------------


void Socket0_Closing(void)
{
//This process should be processed in case that connection is closed after data exchange,
// socket should be closed with Timeout occurrence, 
// or forcible disconnection is necessary due to abnormal operation.
  

                    printf(">going to Close Socket0 ..... \r\n");
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ
           
// засылаем в Регистр Команд сокета0  код на ЗАКРЫТИЕ сокета
SetW5100register(S0_CR, CLOSE);


                   printf(">  ------ Socket CLOSED    ----- \r\n\r\n");
                      // для отладки (вывод на терминал)  МОЖНО УДАЛИТЬ

}
 




// ---- ЗАПИСЬ (посылка) байта  через SPI   -------------
//--------------------------------------------------------


//* у меня название функции «SSPI» оттого, что в компайлере есть собственная 
// готовая йункция (SPI… )но она глючная. Поэтому я написал свой вариант 
// а чтоб не было конфликтов в компайлере – дал ей другое имя

// назначение функции – записать  ОДИН БАЙТ
//  более верхние уровни «протокола»  обмена реализует 
// собственно функция для записи в РЕГИСТР

//* данные на запись в регистр -  валидные для W5100 при  переходе клока из 0 в 1

void SSPI_write( int Data)
{
int i;
int mask=0x80; // ставим маску на СТАРШИЙ бит (тоесть начинаем со СТАРШЕГО бита)
                // так  как по  протоколу  SPI для W5100 данные следуют 
                // от СТАРШЕГО бита -  к МЛАДШЕМУ  ( MSB first)


output_low(SCK);   // просто чтоб быть уверенными что клок – в «исходном» положении

for (i=0; i<8;i++)    // цикл для считывания 8 бит
 { 
  output_low(MOSI);   // просто выставляем «данные» на линии -  в 0 

  if ( (mask & Data) != 0) output_high(MOSI);   
          // если  (маска & ДАННЫЕ)  =1  то  выставляем на линию 1
         // если нет – то на линии  так и остается 0, выставленный строчкой выше


  output_high(SCK);   
   // выдаем пульс клока ( из 0 в 1)  - именно по нему  происходит запись бита 
   // с линии  данных SPI – в   регистры W5100
 
  mask = mask>>1; ;  // сдвигаем маску  на 1 бит вправо
                    // *можно поставить  эту операцию и  после  цикла
                    // но в этом месте этим заодно  обеспечивается 
                    // некотор задержка между тактами (тоесть частота клока)

 
  output_low(SCK); // завершаем  клок, переводим его в «исходное» состояние ( 0 )
 }
 // «.. и так восэм  рас» (с)

}
//----------------------------------------------------------



//----------- ЧТЕНИЕ байта с линии   SPI  ------------------
//-----------------------------------------------------------


//* у меня название «SSPI» оттого, что в компайлере есть собственная 
// готовая йункция (SPI… )но она глючная. Поэтому я написал свой вариант 
// а чтоб не было конфликтов в компайлере – дал ей другое имя

// назначение функции – прочесть  ОДИН БАЙТ
//  более верхние уровни «протокола» реализует 
// собственно функция  чтения РЕГИСТРА

// *данные при чтении из регистров W5100 -  валидные при  переходе клока из 1 в 0

//* тоесть если при передаче  мы  сначала  выставляли данные на линию
//  и только после этого  подтверждали их валидность переводом клока из 0 в 1
// а  на прниеме  мы сначала  выставляем  клок в 1,  читаем данные
// и «защелкиваем» данные  переходом клока из 1 в 0


int SSPI_read ( void)
{
int Data=0;
int i;
int mask=0x80; // ставим маску на СТАРШИЙ бит (тоесть начинаем со старшего бита)
                // так  как по  протоколу  SPI для W5100 данные следуют 
                // от СТАРШЕГО бита -  к МЛАДШЕМУ  ( MSB first)


output_low(SCK);   // просто чтоб быть уверенными что клок – в «исходном» положении

for (i=0; i<8;i++)  // цикл для считывания 8 бит

 { 
  output_high(SCK);   // выдаем пульс клока ( из 0 в 1)      
    
  if ( input(MISO)!= 0) Data = Data | mask ; 
  // если на линии 1, то  делаем ИЛИ  маски – и текущего  значения «собираемого» байта
  
  mask = mask>>1; ;   // сдвигаем маску  на 1 бит вправо
                    // *можно поставить и  после  цикла
                    // но в этом месте этим заодно  обеспечивается 
                    // некотор задержка между тактами (тоесть частота клока)

  
  output_low(SCK); // завершаем  клок, переводим его в «исходное» состояние ( 0 )

 }

return Data;
}
//---------------------------------------------------------------



//-------  ЗАПИСЬ  ( установка)  регистров W5100 -------------
//--------------------------------------------------------------
void SetW5100register (int16 regaddr, int8 data)
// 2 аргумента: 16 бит адреса регистра и 8 бит данных для записи

{
output_low(SS); // выставляем Чип Селект ( ставим в 0)

SSPI_write (0xF0);  // сперва  посылаем в регистр команду ЗАПИСЬ

                                   //*  make8 – преобразует 16 бит - в  8 бит
SSPI_write (  make8(regaddr,1) );  // выделяем из адреса старший байт  (MSB)
                                   // и пишем  его на SPI     


SSPI_write (  make8(regaddr,0) );  // выделяем из адреса младший байт  (LSB)
                                   // и шлем  его на SPI  

SSPI_write (data);   // пишем на SPI ДАННЫЕ для записи в регистр 


output_high(SS);     //  снимаем ЧипСелект  ( ставим в 1)

}
//---------------------------------------------------------




//-----  ЧТЕНИЕ содержимого регистров W5100 ----------
//----------------------------------------------------
int  GetW5100register (int16 regaddr)
//аргумент – 2-байтовый адрес регистра
// возвращает: 1 байт считанных из регистра данных
{
int RegData;

output_low(SS); // выставляем Чип Селект ( ставим в 0)


SSPI_write (0x0F);  // сперва  засылаем команду ЧТЕНИЕ

                                   //*  make8 – преобразует 16 бит в  8 бит
SSPI_write (  make8(regaddr,1) );  //  выделяем из адреса старший байт  (MSB)
                                   // и выставляем его на SPI     

SSPI_write (  make8(regaddr,0) );  //  выделяем из адреса младший байт  (LSB)
                                   // и выставляем его на SPI  

RegData = SSPI_read ();    // теперь в ответ W5100  выдаст нам содержимое (8 бит) 
                           // регистра по засланному перед этим адресу


output_high(SS);    //  снимаем ЧипСелект  ( ставим в 1)

return RegData;	// выходим с  прочитанным байтом

}
 
 
  
//*************  END of PROGRAM  **************



